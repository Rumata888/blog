<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>CTFZone 2022 Buggy ASM challenge writeup | Random thoughts about applied cryptography and fuzzing</title>
<meta name=keywords content="CTF,Cryptography,Bugs,ASM">
<meta name=description content="I explore how a field implementation bug in assembly can be exploited to leak the private key in in ECDH (elliptic curve Diffie-Hellman) in a very CTF situation">
<meta name=author content="Rumata888">
<link rel=canonical href=https://cryptography.zone/posts/buggy-asm/>
<link crossorigin=anonymous href=/assets/css/stylesheet.6e97a6b79be998515e8c86c68e32a9f7a90e6917f550d2af32568b717f5ca785.css integrity="sha256-bpemt5vpmFFejIbGjjKp96kOaRf1UNKvMlaLcX9cp4U=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://cryptography.zone/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://cryptography.zone/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://cryptography.zone/favicon-32x32.png>
<link rel=apple-touch-icon href=https://cryptography.zone/apple-touch-icon.png>
<link rel=mask-icon href=https://cryptography.zone/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css integrity=sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js integrity=sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:!0},{left:'$',right:'$',display:!1},{left:'\\(',right:'\\)',display:!1},{left:'\\[',right:'\\]',display:!0}],throwOnError:!1})})</script>
<div id=cookie-notice>
<span>We would like to use third party cookies and scripts to improve the
functionality of this website.</span>
<a id=cookie-notice-accept class="btn btn-primary btn-sm">Approve</a>
<a id=cookie-notice-deny class="btn btn-primary btn-sm">Deny</a>
<a href=/privacy class="btn btn-primary btn-sm">More info</a></div>
<script>function createCookie(d,e,b){var c="",a;b&&(a=new Date,a.setTime(a.getTime()+b*24*60*60*1e3),c="; expires="+a.toUTCString()),document.cookie=d+"="+e+c+"; path=/"}function readCookie(e){for(var c=e+"=",d=document.cookie.split(';'),b=0,a;b<d.length;b++){for(a=d[b];a.charAt(0)==' ';)a=a.substring(1,a.length);if(a.indexOf(c)==0)return a.substring(c.length,a.length)}return null}function eraseCookie(a){createCookie(a,"",-1)}if(readCookie('cookie-notice-option')=='true'){function loadScriptAsync(c,b){if(typeof b!='function')throw new Error('Not a valid callback for async script load');var a=document.createElement('script');a.onload=b,a.src=c,document.head.appendChild(a)}loadScriptAsync('https://www.googletagmanager.com/gtag/js?id=G-SZDG9FZ566',function(){window.dataLayer=window.dataLayer||[];function a(){dataLayer.push(arguments)}a('js',new Date),a('config','G-SZDG9FZ566',{anonymize_ip:!1})})}else readCookie('cookie-notice-option')!='false'&&(document.getElementById('cookie-notice').style.display='block');document.getElementById('cookie-notice-accept').addEventListener("click",function(){createCookie('cookie-notice-option','true',31),document.getElementById('cookie-notice').style.display='none',location.reload()}),document.getElementById('cookie-notice-deny').addEventListener("click",function(){createCookie('cookie-notice-option','false',31),document.getElementById('cookie-notice').style.display='none',location.reload()})</script>
<meta property="og:title" content="CTFZone 2022 Buggy ASM challenge writeup">
<meta property="og:description" content="I explore how a field implementation bug in assembly can be exploited to leak the private key in in ECDH (elliptic curve Diffie-Hellman) in a very CTF situation">
<meta property="og:type" content="article">
<meta property="og:url" content="https://cryptography.zone/posts/buggy-asm/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-09-02T19:55:35+01:00">
<meta property="article:modified_time" content="2022-09-02T19:55:35+01:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="CTFZone 2022 Buggy ASM challenge writeup">
<meta name=twitter:description content="I explore how a field implementation bug in assembly can be exploited to leak the private key in in ECDH (elliptic curve Diffie-Hellman) in a very CTF situation">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://cryptography.zone/posts/"},{"@type":"ListItem","position":2,"name":"CTFZone 2022 Buggy ASM challenge writeup","item":"https://cryptography.zone/posts/buggy-asm/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CTFZone 2022 Buggy ASM challenge writeup","name":"CTFZone 2022 Buggy ASM challenge writeup","description":"I explore how a field implementation bug in assembly can be exploited to leak the private key in in ECDH (elliptic curve Diffie-Hellman) in a very CTF situation","keywords":["CTF","Cryptography","Bugs","ASM"],"articleBody":"Introduction Some time ago Guido Vranken (please check out his blog) stumbled upon the cryptographic library Barretenberg that is being developed by our team at Aztec Protocol. As the creator of probably the most successful differential cryptographic fuzzer there is, he quickly found several bugs that our internal audits had overlooked. One of the more serious ones that he found was a bug in the assembly code intended to perform Montgomery squaring. It reminded me of the last cryptopals challenge that I had read but never actually tried to solve. As one of the organizers of CTFZone I was in search of a CTF task idea, so I decided to make a task out of it while analyzing what could actually happen and if there are any similar vulnerabilities in our code.\nIf you want to try and solve the task youself, it is available here and the server is running on port 1353 of cryptraining.zone. If you just want to look at the code of the solution, you can find it here.\nThis writeup assumes familiarity with how finite field and elliptic curves work, so I won’t be covering those topics in depth. I’m sure that whoever is reading this will easily find a nice introduction into those topics online.\nMontgomery multiplication The core bug was in the way we performed squaring or field elements in Montgomery form. Montgomery multiplication is one of optimizations that can be used to speed up finite field multiplication. Let’s say we have some finite field modulo prime $p$ (in the task $p$ is around 254 bits, it’s the alt_bn128 curve). We find the closest convenient power of two (in this case $2^{256}$) and convert field elements into the form $a=a_{original}*R\\ mod\\ p$. Then, when we multiply two elements $a$ and $b$ we get the following value:\n$a⋅b = a_{original}⋅ R⋅ b_{original}⋅ R= a_{original}⋅ b_{original}⋅ R^2\\ mod\\ p$\nNow, to get the result back to Montgomery form we need to divide it by $R$. The cool thing is that since $R$ is a power of 2, it is very easy to perform this division if we manage to make the intermediate product a multiple of $R$ in integer form. Let’s look at an example:\n $p=15541=\\text{0x3cb5}$ $R=2^{16} = 3372\\ mod\\ p$ $a_{original}=2\\ mod\\ p$ $b_{original}=2^{-1}\\ mod\\ p = 7771\\ mod\\ p$ $a=a_{original}⋅R=6744\\ mod\\ p$ $b=b_{original}⋅ R= 1686\\ mod\\ p$  Now that we have the converted values:\n$a⋅b = 6744⋅1686 = 11370384 = \\text{0xad7f90}$\nThe value is obviously too large to fit the modulus\nIf we compute the integer product of two values:\n $(-p)^{-1}\\ mod\\ R = 11875 =\\text{0x2e63}$ $a⋅b= \\text{0x7f90}\\ mod\\ R$  the result:\n$l=(a⋅b\\ mod\\ R) ⋅ (-p^{-1}\\ mod\\ R) ⋅ p$\nwould have several cool features:\n $l = - a⋅b\\ mod\\ R$; or, to put it simply, if we add this value to the product, then the result will be 0 modulo $R$ $l = 0\\ mod\\ p$; which means that by adding the value we are not changing the result modulo $p$  $l = \\text{0x7f90} ⋅ \\text{0x2e63}\\ mod\\ R ⋅ \\text{0x3cb5}= \\text{0x34b0}⋅ \\text{0x3cb5} = \\text{0xc7e8070}$\n$a⋅b + l = \\text{0xad7f90} + \\text{0xc7e8070} = \\text{0xd2c0000}$\nWe can now easily divide this value by $R$, getting\n$(a⋅b + l)/\\text{0x10000} = \\text{0xd2c}$.\nIn assembly this would be even simpler, since we’d just have to forget the values of certain registers. The final value is less then $p$. If we convert it back to original form, $\\text{0xd2c}*R^{-1}= 1\\ mod\\ p$ as we expected\nN.B. The conversions themselves are also really simple. To convert $a_{original}$ to $a$ all we have to do is to do montgomery multiplication of $a_{original}$ by $R$ in Montgomery form ($R^2$):\n$a_{original}⋅(R⋅R)/R = a_{original}⋅R = a\\ mod\\ p$.\nTo convert back to the original form we simply multiply by 1 and automatic division takes care of one $R$.\nThe curve in barretenberg obviously uses a bigger field than in the example (254-bit one), but overall the same logic applies. The only difference is that instead of computing the full product and then adding a multiple of $p$ that would nullify the lowest 256 bits ($R=2^{256}$ in this case), once we’ve computed each 64-bit chunk of $a⋅b$ we nullify just that chunk by adding an appropriate multiple of $p$. This makes the algorithm a bit less complex.\nBugs in Barretenberg’s Montgomery squaring Barretenberg has 2 assembly versions of Montgomery squaring and multiplication algorithms. One uses BMI2 ADX extensions taking advantage of parallel additions with adcx and adox instructions and one is a simplified version that was only written to accommodate those with x86_64 CPUs without this extension. Both versions can be found in asm_macros.hpp. The non-ADX version was created from ADX version, but in doing so we created several bugs.\nThe assembly implementation is pretty simple:\n We multiply single digits We add them to compute the digits of the intermediate product When we have computed the digit of the intermediate product completely, we use montgomery reduction on the digit to nullify it through the process described in the previous paragraph We simply forget the nullified digits, so in the end we are left with 4 registers r12-r15 with the resulting value  We do squaring separately from regular multiplication, because there is an opportunity to speed up computation by performing certain digit multiplication once and then doubling the result (for example instead of multiplying a[0]⋅a[1] and a[1]⋅a[0] and then adding them together, we simply add the first product to itself).\nThere are several bugs in this function, but let’s look at the first one. This was the one triggered by one of the traffic captures distributed with the task.\n\"movq 0(\" a \"), %%rdx \\n\\t\" /* load a[0] into %rdx */ \\ \\ \"xorq %%r8, %%r8 \\n\\t\" /* clear flags */ \\ /* compute a[0] *a[1], a[0]*a[2], a[0]*a[3], a[1]*a[2], a[1]*a[3], a[2]*a[3] */ \\ \"mulxq 8(\" a \"), %%r9, %%r10 \\n\\t\" /* (r[1], r[2]) \\ \"mulxq 16(\" a \"), %%r8, %%r15 \\n\\t\" /* (t[1], t[2]) \\ \"mulxq 24(\" a \"), %%r11, %%r12 \\n\\t\" /* (r[3], r[4]) \\ \\ \\ /* accumulate products into result registers */ \\ \"addq %%r8, %%r10 \\n\\t\" /* r[2] += t[1] */ \\ \"adcq %%r15, %%r11 \\n\\t\" /* r[3] += t[2] */ \\ \"movq 8(\" a \"), %%rdx \\n\\t\" /* load a[1] into %r%dx */ \\ \"mulxq 16(\" a \"), %%r8, %%r15 \\n\\t\" /* (t[5], t[6]) \\ \"mulxq 24(\" a \"), %%rdi, %%rcx \\n\\t\" /* (t[3], t[4]) \\ \"movq 24(\" a \"), %%rdx \\n\\t\" /* load a[3] into %%rdx */ \\ \"mulxq 16(\" a \"), %%r13, %%r14 \\n\\t\" /* (r[5], r[6]) \\ \"adcq %%rdi, %%r12 \\n\\t\" /* r[4] += t[3] */ \\ \"adcq %%rcx, %%r13 \\n\\t\" /* r[5] += t[4] + flag_c */ \\ \"adcq $0, %%r14 \\n\\t\" /* r[6] += flag_c */ \\ \"addq %%r8, %%r11 \\n\\t\" /* r[3] += t[5] */ \\ \"adcq %%r15, %%r12 \\n\\t\" /* r[4] += t[6] */ \\ \"adcq $0, %%r13 \\n\\t\" /* r[5] += flag_c */ \\ \\ /* double result registers */ \\ \"addq %%r9, %%r9 \\n\\t\" /* r[1] = 2r[1] */ Here we multiply a[0] by a[0-3] and start sequential additions. Then we multiply a[1] by a[2] and a[3], and a[2] by a[3]. The last in the first serie of additions you see here is\n\"adcq $0, %%r13\" and after that we start doubling registers, while using the instruction “addq”. The bug here is that this “adcq” can actually set the carry flag, which should be once again added to the r14 register, but this insturction is missing. Instead the flag is overwritten by the following instruction. Having lost the flag, we compute an erroneous value.\nThis code contains several places where carry flags are simply lost. In fact, since there are fewer and fewer people who use non-ADX version we decided that it’s easier to replace this SQR with the multiplication primitive because of the time-cost of fixing it.\nThe CTF task required contestants to find several faulting inputs to the SQR function as part of the solution and we gave teams an example of an buggy input. It is possible to implement smart bruteforce, where you try to generate inputs that would force r13 to be equal to 0xffffffffffffffff before the last addition (the tester of the task solved it that way). I’m lazy, so I used automation instead of thinking. Since there are very few different instructions it was easy to encode them as z3 (SMT solver) formulas, like this:\ndef addq(args): var_in_1 = get_asm_input(args[0]) var_in_2 = get_asm_input(args[1]) var_out = get_output_variable(args[1]) CF_out = get_output_flag(\"CF\") temp = z3.ZeroExt(1, var_in_1) + z3.ZeroExt(1, var_in_2) machine_state.instructions.append( var_out == z3.Extract(register_width - 1, 0, temp) ) machine_state.instructions.append( CF_out == z3.Extract(register_width, register_width, temp) ) Then the script would go through all carry flags that were never used again and check if it was possible to find corresponding inputs. I chose several flags that were being solved by z3 fast enough. In the end I had a module, which rotated through several flag options, trying to solve them and banning previous solutions. The process is time-consuming, so once the teams found the root cause of the bug it would have been wise to set up the algorithm to find several buggy inputs before analyzing the task further. In my case on 1 thread it took around 30 minutes to find enough inputs for the other part of the task.\nNow that we’ve covered the core bug, let’s look at the task itself.\nBuggy Asm Task Task structure The contestants were given an archive with:\n A server (source code) for the task for analysis A client (source code) for the task to interact with the server A capture of network traffic with the legitimate user authenticating on the server A partial capture of a previous attack (they could find the asm bug this way)  The client-server workflow was the following:\n Client connects to the server, they do an ECDH exchange Clients sends encrypted password to the server Server answers with the encrypted flag  The goal was to find out server’s private key. Nothing new, pretty standard for CTFs. Session logic is implemented like this:\nextern \"C\" bool createSession(ServerState* pServerState, uint8_t* pPointCoordinates, char* pErrorMessage) { std::stringstream errorStream; fq clientPointX(*(uint256_t*)(pPointCoordinates)), clientPointY(*(uint256_t*)(pPointCoordinates + sizeof(uint256_t))); g1::affine_element clientPoint(clientPointX, clientPointY); if (!clientPoint.on_curve()) { errorStream  \"Input point \"  clientPoint  \" is not on curve\"  std::endl; strcpy(pErrorMessage, errorStream.str().c_str()); return false; } g1::affine_element sharedPoint = g1::affine_element( g1::element(clientPoint * fr(2)).mul_without_endomorphism(pServerState-privateKey * fr(2).invert())); if (!sharedPoint.on_curve()) { errorStream  \"Shared point \"  sharedPoint  \" is not on curve\"  std::endl; strcpy(pErrorMessage, errorStream.str().c_str()); return false; } uint256_t sharedPointX(sharedPoint.x), sharedPointY(sharedPoint.y); std::vectoruint8_t hasherInput; std::vectoruint8_t temp; for (size_t i = 0; i  sizeof(uint256_t); i++) { hasherInput.push_back(((uint8_t*)(\u0026sharedPointX.data[0]))[i]); } for (size_t i = 0; i  sizeof(uint256_t); i++) { hasherInput.push_back(((uint8_t*)(\u0026sharedPointY.data[0]))[i]); } temp.insert(temp.begin(), hasherInput.begin(), hasherInput.end()); temp.push_back(0); auto encryptionKey = Sha256Hasher::hash(temp); temp.pop_back(); temp.push_back(1); auto macKey = Sha256Hasher::hash(temp); memcpy(pServerState-sessionEncryptionKey, encryptionKey.data(), 32); memcpy(pServerState-sessionMACKey, macKey.data(), 32); return true; } If during ECDH key exchange the client’s public point was not on the curve, the server responded with this information and ended the handshake. The weird thing was that the server also responded with shared point information, if the computed shared point was off the curve. This is a situation you should never run into, since you’re getting an invalid point by scaling a valid one. However, as we covered earlier, the core bug resulted in erroneous field element squaring. This would make the point fall off the curve onto another one, which might not be as secure. To help solvers the original public point was actually doubled initially and then all operations were performed on the doubled point. This was done to stabilize the task, as I’m not sure that a task with regular scalar multiplication would be solvable at all.\nFinding failure-inducing points The goal was to submit a valid point that would fall off the curve during the doubling operation. To understand how we could do that,let’s look at how doubling of EC points is performed in barretenberg.\ntemplate class Fq, class Fr, class T constexpr void elementFq, Fr, T::self_dbl() noexcept { if constexpr (Fq::modulus.data[3] = 0x4000000000000000ULL) { if (is_point_at_infinity()) { self_set_infinity(); return; } } else { if (x.is_msb_set_word()) { self_set_infinity(); return; } } // T0 = x*x  Fq T0 = x.sqr(); // T1 = y*y  Fq T1 = y.sqr(); // T2 = T2*T1 = y*y*y*y  Fq T2 = T1.sqr(); // T1 = T1 + x = x + y*y  T1 += x; // T1 = T1 * T1  T1.self_sqr(); // T3 = T0 + T2 = xx + y*y*y*y  Fq T3 = T0 + T2; // T1 = T1 - T3 = x*x + y*y*y*y + 2*x*x*y*y*y*y - x*x - y*y*y*y = 2*x*x*y*y*y*y = 2*S  T1 -= T3; // T1 = 2T1 = 4*S  T1 += T1; // T3 = 3T0  T3 = T0 + T0; T3 += T0; if constexpr (T::has_a) { T3 += (T::a * z.sqr().sqr()); } // z2 = 2*y*z  z += z; z *= y; // T0 = 2T1  T0 = T1 + T1; // x2 = T3*T3  x = T3.sqr(); // x2 = x2 - 2T1  x -= T0; // T2 = 8T2  T2 += T2; T2 += T2; T2 += T2; // y2 = T1 - x2  y = T1 - x; // y2 = y2 * T3 - T2  y *= T3; y -= T2; } We see that doubling uses projective coordinates (instead of $(x,y)$ we have $(X,Y,Z)$). If you are unfamiliar with this form, it is used to speed up computation. Affine form $(x,y)$ depends on division during computation of $\\lambda$ during addition and doubling operation. Division in finite fields is extremely computationally expensive, since you need to either exponentiate the value to the power of $p-2$ or use extended euclidean algorithm to find the inverse. Projective coordinate form deals with these pains by saving division for last. In projective form you have to perform expensive divison to convert back to affine form only after you’ve computed the final point.\nIn the code we see several sqr and self_sqr calls that we are interested in here. For example, both $x$ and $y$ get squared, so why don’t we simply place the bug-inducing value in $x$ or $y$ and try to compute a conforming point? There are 2 issues:\n Such a point might simply not exist. For example, if we set $x$ to a particular value, that doesn’t automatically mean that the curve equation $y^2=x^3+b$ (the curve in barretenberg has $a=0$) will have roots (there is a 50% chance). The initial check performed by the server ensures that $y^2=x^3+b$, so if we put the buggy value directly in $x$ or $y$ the first check will fail, so we need to be smarter.  So we need to find other “squares”. Here they are:\n $3x^2$. We needed to check that $\\frac{\\mathit{buggy\\_value}}{3}\\ mod\\ p$ is a quadratic residue, then compute two possible $x$ if it was and check if we could derive valid points from those.  // T0 = x*x  Fq T0 = x.sqr(); // T3 = 3T0  T3 = T0 + T0; T3 += T0; // x2 = T3*T3  x = T3.sqr(); $y^2$. Here we needed to check that the buggy value is a quadratic residue and find solutions to equation $x^3+3-\\mathit{buggy\\_value}=0$  // T1 = y*y  Fq T1 = y.sqr(); // T2 = T2*T1 = y*y*y*y  Fq T2 = T1.sqr(); $x+y^2$ We needed to find solutions to the equation $x^3+x+3-\\mathit{buggy\\_value}=0$. Then check that there are actually points on those $x$.  // T0 = x*x  Fq T0 = x.sqr(); // T1 = y*y  Fq T1 = y.sqr(); // T1 = T1 + x = x + y*y  T1 += x; // T1 = T1 * T1  T1.self_sqr(); To simplify checks, I added a library function that just doubled the point using buggy code.\nBarretenberg assumes that the point is on curve $y^2=x^3+b$, where $b$ is embedded in the point itself, so it takes no part in computation. Knowing $(x,y)$ it is easy to compute $b$ and then it’s possible to compute the curve’s order.\nI factored all the orders and collected points with subgroups small enough to be useful. Once I had enough buggy points, I could send them to the server, get erroneous shared points and solve discrete logarithm in subgroups using pollard’s rho algorithm. Using Chinese remainder theorem they could reconstruct the private key.\nAfter reconstructing the private key contestants could simply assume the role of the server, replay the conversation with authentication and decrypt the password. Then all that was left is to submit it to the server.\nComplete Solution  Discover buggy flags in assembly, create a script to generate various inputs triggering those bugs and producing erroneous squared values Convert those values back from Montgomery form. Put them into the three equations and check if there are roots. If there are roots, compute the points. Check that the points actually trigger bugs and if they do, save them and resulting points on other curves. Check curves' orders. Factor them and collect subgroups with solvable dlog. Once there are enough subgroups so that the CRT of their orders is larger than the original scalar group order by a few factors, switch to interacting with the server. Send buggy points to the server and receive shared points that should now be on other curves. Solve appropriate subgroup dlogs. Reconstuct server’s private key Replay the legitimate capture that is distributed with the task, assuming the role of the server and get the decrypted password. Send it to the server and get the flag.  ","wordCount":"2937","inLanguage":"en","datePublished":"2022-09-02T19:55:35+01:00","dateModified":"2022-09-02T19:55:35+01:00","author":{"@type":"Person","name":"Rumata888"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cryptography.zone/posts/buggy-asm/"},"publisher":{"@type":"Organization","name":"Random thoughts about applied cryptography and fuzzing","logo":{"@type":"ImageObject","url":"https://cryptography.zone/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://cryptography.zone/ accesskey=h title="Random thoughts about applied cryptography and fuzzing (Alt + H)">Random thoughts about applied cryptography and fuzzing</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://cryptography.zone/>Home</a>&nbsp;»&nbsp;<a href=https://cryptography.zone/posts/>Posts</a></div>
<h1 class=post-title>
CTFZone 2022 Buggy ASM challenge writeup
</h1>
<div class=post-description>
I explore how a field implementation bug in assembly can be exploited to leak the private key in in ECDH (elliptic curve Diffie-Hellman) in a very CTF situation
</div>
<div class=post-meta><span title="2022-09-02 19:55:35 +0100 BST">September 2, 2022</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;2937 words&nbsp;·&nbsp;Rumata888
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><nav id=TableOfContents>
<ul>
<li><a href=#introduction>Introduction</a></li>
<li><a href=#montgomery-multiplication>Montgomery multiplication</a></li>
<li><a href=#bugs-in-barretenbergs-montgomery-squaring>Bugs in Barretenberg&rsquo;s Montgomery squaring</a></li>
<li><a href=#buggy-asm-task>Buggy Asm Task</a>
<ul>
<li><a href=#task-structure>Task structure</a></li>
<li><a href=#finding-failure-inducing-points>Finding failure-inducing points</a></li>
</ul>
</li>
<li><a href=#complete-solution>Complete Solution</a></li>
</ul>
</nav>
</div>
</details>
</div>
<div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2>
<p>Some time ago Guido Vranken (please check out his <a href=https://guidovranken.com/>blog</a>) stumbled upon the cryptographic library <a href=https://github.com/AztecProtocol/barretenberg>Barretenberg</a> that is being developed by our team at Aztec Protocol. As the creator of probably the most successful differential cryptographic fuzzer there is, he quickly found several bugs that our internal audits had overlooked. One of the more serious ones that he found was a bug in the assembly code intended to perform Montgomery squaring. It reminded me of the last <a href=https://cryptopals.com/sets/8/challenges/66.txt>cryptopals challenge</a> that I had read but never actually tried to solve. As one of the organizers of CTFZone I was in search of a CTF task idea, so I decided to make a task out of it while analyzing what could actually happen and if there are any similar vulnerabilities in our code.</p>
<p>If you want to try and solve the task youself, it is available <a href=https://github.com/Rumata888/buggy-asm-task>here</a> and the server is running on port 1353 of cryptraining.zone. If you just want to look at the code of the solution, you can find it <a href=https://github.com/Rumata888/buggy-asm-solution>here</a>.</p>
<p>This writeup assumes familiarity with how finite field and elliptic curves work, so I won&rsquo;t be covering those topics in depth. I&rsquo;m sure that whoever is reading this will easily find a nice introduction into those topics online.</p>
<h2 id=montgomery-multiplication>Montgomery multiplication<a hidden class=anchor aria-hidden=true href=#montgomery-multiplication>#</a></h2>
<p>The core bug was in the way we performed squaring or field elements in Montgomery form. Montgomery multiplication is one of optimizations that can be used to speed up finite field multiplication. Let&rsquo;s say we have some finite field modulo prime $p$ (in the task $p$ is around 254 bits, it&rsquo;s the <a href=https://github.com/ethereum/EIPs/blob/master/EIPS/eip-197.md>alt_bn128</a> curve). We find the closest convenient power of two (in this case $2^{256}$) and convert field elements into the form $a=a_{original}*R\ mod\ p$. Then, when we multiply two elements $a$ and $b$ we get the following value:</p>
<p>$a⋅b = a_{original}⋅ R⋅ b_{original}⋅ R= a_{original}⋅ b_{original}⋅ R^2\ mod\ p$</p>
<p>Now, to get the result back to Montgomery form we need to divide it by $R$. The cool thing is that since $R$ is a power of 2, it is very easy to perform this division if we manage to make the intermediate product a multiple of $R$ in integer form. Let&rsquo;s look at an example:</p>
<ul>
<li>$p=15541=\text{0x3cb5}$</li>
<li>$R=2^{16} = 3372\ mod\ p$</li>
<li>$a_{original}=2\ mod\ p$</li>
<li>$b_{original}=2^{-1}\ mod\ p = 7771\ mod\ p$</li>
<li>$a=a_{original}⋅R=6744\ mod\ p$</li>
<li>$b=b_{original}⋅ R= 1686\ mod\ p$</li>
</ul>
<p>Now that we have the converted values:</p>
<p>$a⋅b = 6744⋅1686 = 11370384 = \text{0xad7f90}$</p>
<p>The value is obviously too large to fit the modulus</p>
<p>If we compute the integer product of two values:</p>
<ul>
<li>$(-p)^{-1}\ mod\ R = 11875 =\text{0x2e63}$</li>
<li>$a⋅b= \text{0x7f90}\ mod\ R$</li>
</ul>
<p>the result:</p>
<p>$l=(a⋅b\ mod\ R) ⋅ (-p^{-1}\ mod\ R) ⋅ p$</p>
<p>would have several cool features:</p>
<ol>
<li>$l = - a⋅b\ mod\ R$; or, to put it simply, if we add this value to the product, then the result will be 0 modulo $R$</li>
<li>$l = 0\ mod\ p$; which means that by adding the value we are not changing the result modulo $p$</li>
</ol>
<p>$l = \text{0x7f90} ⋅ \text{0x2e63}\ mod\ R ⋅ \text{0x3cb5}= \text{0x34b0}⋅ \text{0x3cb5} = \text{0xc7e8070}$</p>
<p>$a⋅b + l = \text{0xad7f90} + \text{0xc7e8070} = \text{0xd2c0000}$</p>
<p>We can now easily divide this value by $R$, getting</p>
<p>$(a⋅b + l)/\text{0x10000} = \text{0xd2c}$.</p>
<p>In assembly this would be even simpler, since we&rsquo;d just have to forget the values of certain registers. The final value is less then $p$. If we convert it back to original form, $\text{0xd2c}*R^{-1}= 1\ mod\ p$ as we expected</p>
<p>N.B. The conversions themselves are also really simple. To convert $a_{original}$ to $a$ all we have to do is to do montgomery multiplication of $a_{original}$ by $R$ in Montgomery form ($R^2$):</p>
<p>$a_{original}⋅(R⋅R)/R = a_{original}⋅R = a\ mod\ p$.</p>
<p>To convert back to the original form we simply multiply by 1 and automatic division takes care of one $R$.</p>
<p>The curve in barretenberg obviously uses a bigger field than in the example (254-bit one), but overall the same logic applies. The only difference is that instead of computing the full product and then adding a multiple of $p$ that would nullify the lowest 256 bits ($R=2^{256}$ in this case), once we&rsquo;ve computed each 64-bit chunk of $a⋅b$ we nullify just that chunk by adding an appropriate multiple of $p$. This makes the algorithm a bit less complex.</p>
<h2 id=bugs-in-barretenbergs-montgomery-squaring>Bugs in Barretenberg&rsquo;s Montgomery squaring<a hidden class=anchor aria-hidden=true href=#bugs-in-barretenbergs-montgomery-squaring>#</a></h2>
<p>Barretenberg has 2 assembly versions of Montgomery squaring and multiplication algorithms. One uses BMI2 ADX extensions taking advantage of parallel additions with <em>adcx</em> and <em>adox</em> instructions and one is a simplified version that was only written to accommodate those with x86_64 CPUs without this extension. Both versions can be found in <a href=https://github.com/Rumata888/aztec-2/blob/master/barretenberg/src/aztec/ecc/fields/asm_macros.hpp>asm_macros.hpp</a>. The non-ADX version was created from ADX version, but in doing so we created several bugs.</p>
<p>The assembly implementation is pretty simple:</p>
<ul>
<li>We multiply single digits</li>
<li>We add them to compute the digits of the intermediate product</li>
<li>When we have computed the digit of the intermediate product completely, we use montgomery reduction on the digit to nullify it through the process described in the previous paragraph</li>
<li>We simply forget the nullified digits, so in the end we are left with 4 registers <em>r12</em>-<em>r15</em> with the resulting value</li>
</ul>
<p>We do squaring separately from regular multiplication, because there is an opportunity to speed up computation by performing certain digit multiplication once and then doubling the result (for example instead of multiplying a[0]⋅a[1] and a[1]⋅a[0] and then adding them together, we simply add the first product to itself).</p>
<p>There are several bugs in this function, but let&rsquo;s look at the first one. This was the one triggered by one of the traffic captures distributed with the task.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>        <span style=color:#e6db74>&#34;movq 0(&#34;</span> a <span style=color:#e6db74>&#34;), %%rdx                     </span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span> <span style=color:#75715e>/* load a[0] into %rdx */</span>                                       \
                                                                                                                        \
        <span style=color:#e6db74>&#34;xorq %%r8, %%r8                          </span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span> <span style=color:#75715e>/* clear flags                                              */</span>  \
        <span style=color:#75715e>/* compute a[0] *a[1], a[0]*a[2], a[0]*a[3], a[1]*a[2], a[1]*a[3], a[2]*a[3]                                */</span>  \
        <span style=color:#e6db74>&#34;mulxq 8(&#34;</span> a <span style=color:#e6db74>&#34;), %%r9, %%r10              </span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span> <span style=color:#75715e>/* (r[1], r[2]) &lt;- a[0] * a[1]                              */</span>  \
        <span style=color:#e6db74>&#34;mulxq 16(&#34;</span> a <span style=color:#e6db74>&#34;), %%r8, %%r15             </span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span> <span style=color:#75715e>/* (t[1], t[2]) &lt;- a[0] * a[2]                              */</span>  \
        <span style=color:#e6db74>&#34;mulxq 24(&#34;</span> a <span style=color:#e6db74>&#34;), %%r11, %%r12            </span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span> <span style=color:#75715e>/* (r[3], r[4]) &lt;- a[0] * a[3]                              */</span>  \
                                                                                                                        \
                                                                                                                        \
        <span style=color:#75715e>/* accumulate products into result registers */</span>                                                                 \
        <span style=color:#e6db74>&#34;addq %%r8, %%r10                         </span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span> <span style=color:#75715e>/* r[2] += t[1]                                             */</span>  \
        <span style=color:#e6db74>&#34;adcq %%r15, %%r11                        </span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span> <span style=color:#75715e>/* r[3] += t[2]                                             */</span>  \
        <span style=color:#e6db74>&#34;movq 8(&#34;</span> a <span style=color:#e6db74>&#34;), %%rdx                     </span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span> <span style=color:#75715e>/* load a[1] into %r%dx                                     */</span>  \
        <span style=color:#e6db74>&#34;mulxq 16(&#34;</span> a <span style=color:#e6db74>&#34;), %%r8, %%r15             </span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span> <span style=color:#75715e>/* (t[5], t[6]) &lt;- a[1] * a[2]                              */</span>  \
        <span style=color:#e6db74>&#34;mulxq 24(&#34;</span> a <span style=color:#e6db74>&#34;), %%rdi, %%rcx            </span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span> <span style=color:#75715e>/* (t[3], t[4]) &lt;- a[1] * a[3]                              */</span>  \
        <span style=color:#e6db74>&#34;movq 24(&#34;</span> a <span style=color:#e6db74>&#34;), %%rdx                    </span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span> <span style=color:#75715e>/* load a[3] into %%rdx                                     */</span>  \
        <span style=color:#e6db74>&#34;mulxq 16(&#34;</span> a <span style=color:#e6db74>&#34;), %%r13, %%r14            </span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span> <span style=color:#75715e>/* (r[5], r[6]) &lt;- a[3] * a[2]                              */</span>  \
        <span style=color:#e6db74>&#34;adcq %%rdi, %%r12                        </span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span> <span style=color:#75715e>/* r[4] += t[3]                                             */</span>  \
        <span style=color:#e6db74>&#34;adcq %%rcx, %%r13                        </span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span> <span style=color:#75715e>/* r[5] += t[4] + flag_c                                    */</span>  \
        <span style=color:#e6db74>&#34;adcq $0, %%r14                           </span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span> <span style=color:#75715e>/* r[6] += flag_c                                           */</span>  \
        <span style=color:#e6db74>&#34;addq %%r8, %%r11                         </span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span> <span style=color:#75715e>/* r[3] += t[5]                                             */</span>  \
        <span style=color:#e6db74>&#34;adcq %%r15, %%r12                        </span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span> <span style=color:#75715e>/* r[4] += t[6]                                             */</span>  \
        <span style=color:#e6db74>&#34;adcq $0, %%r13                           </span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span> <span style=color:#75715e>/* r[5] += flag_c                                           */</span>  \
                                                                                                                        \
        <span style=color:#75715e>/* double result registers  */</span>                                                                                  \
        <span style=color:#e6db74>&#34;addq %%r9, %%r9                          </span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>&#34;</span> <span style=color:#75715e>/* r[1] = 2r[1]                                             */</span> 
</code></pre></div><p>Here we multiply a[0] by a[0-3] and start sequential additions. Then we multiply a[1] by a[2] and a[3], and a[2] by a[3]. The last in the first serie of additions you see here is</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#e6db74>&#34;adcq $0, %%r13&#34;</span>
</code></pre></div><p>and after that we start doubling registers, while using the instruction &ldquo;addq&rdquo;. The bug here is that this &ldquo;adcq&rdquo; can actually set the carry flag, which should be once again added to the <em>r14</em> register, but this insturction is missing. Instead the flag is overwritten by the following instruction. Having lost the flag, we compute an erroneous value.</p>
<p>This code contains several places where carry flags are simply lost. In fact, since there are fewer and fewer people who use non-ADX version we decided that it&rsquo;s easier to replace this SQR with the multiplication primitive because of the time-cost of fixing it.</p>
<p>The CTF task required contestants to find several faulting inputs to the SQR function as part of the solution and we gave teams an example of an buggy input. It is possible to implement smart bruteforce, where you try to generate inputs that would force <em>r13</em> to be equal to 0xffffffffffffffff before the last addition (the tester of the task solved it that way). I&rsquo;m lazy, so I used automation instead of thinking. Since there are very few different instructions it was easy to encode them as z3 (SMT solver) formulas, like this:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>addq</span>(args):
    var_in_1 <span style=color:#f92672>=</span> get_asm_input(args[<span style=color:#ae81ff>0</span>])
    var_in_2 <span style=color:#f92672>=</span> get_asm_input(args[<span style=color:#ae81ff>1</span>])
    var_out <span style=color:#f92672>=</span> get_output_variable(args[<span style=color:#ae81ff>1</span>])
    CF_out <span style=color:#f92672>=</span> get_output_flag(<span style=color:#e6db74>&#34;CF&#34;</span>)
    temp <span style=color:#f92672>=</span> z3<span style=color:#f92672>.</span>ZeroExt(<span style=color:#ae81ff>1</span>, var_in_1) <span style=color:#f92672>+</span> z3<span style=color:#f92672>.</span>ZeroExt(<span style=color:#ae81ff>1</span>, var_in_2)
    machine_state<span style=color:#f92672>.</span>instructions<span style=color:#f92672>.</span>append(
        var_out <span style=color:#f92672>==</span> z3<span style=color:#f92672>.</span>Extract(register_width <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, temp)
    )
    machine_state<span style=color:#f92672>.</span>instructions<span style=color:#f92672>.</span>append(
        CF_out <span style=color:#f92672>==</span> z3<span style=color:#f92672>.</span>Extract(register_width, register_width, temp)
    )
</code></pre></div><p>Then the script would go through all carry flags that were never used again and check if it was possible to find corresponding inputs. I chose several flags that were being solved by z3 fast enough. In the end I had a <a href=https://github.com/Rumata888/buggy-asm-solution/blob/main/extra_flag_solver.py>module</a>, which rotated through several flag options, trying to solve them and banning previous solutions. The process is time-consuming, so once the teams found the root cause of the bug it would have been wise to set up the algorithm to find several buggy inputs before analyzing the task further. In my case on 1 thread it took around 30 minutes to find enough inputs for the other part of the task.</p>
<p>Now that we&rsquo;ve covered the core bug, let&rsquo;s look at the task itself.</p>
<h2 id=buggy-asm-task>Buggy Asm Task<a hidden class=anchor aria-hidden=true href=#buggy-asm-task>#</a></h2>
<h3 id=task-structure>Task structure<a hidden class=anchor aria-hidden=true href=#task-structure>#</a></h3>
<p>The contestants were given an archive with:</p>
<ul>
<li>A server (source code) for the task for analysis</li>
<li>A client (source code) for the task to interact with the server</li>
<li>A capture of network traffic with the legitimate user authenticating on the server</li>
<li>A partial capture of a previous attack (they could find the asm bug this way)</li>
</ul>
<p>The client-server workflow was the following:</p>
<ul>
<li>Client connects to the server, they do an ECDH exchange</li>
<li>Clients sends encrypted password to the server</li>
<li>Server answers with the encrypted flag</li>
</ul>
<p>The goal was to find out server&rsquo;s private key. Nothing new, pretty standard for CTFs. Session logic is implemented like this:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>bool</span> createSession(ServerState<span style=color:#f92672>*</span> pServerState, <span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span> pPointCoordinates, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> pErrorMessage)
{
    std<span style=color:#f92672>::</span>stringstream errorStream;
    fq <span style=color:#a6e22e>clientPointX</span>(<span style=color:#f92672>*</span>(uint256_t<span style=color:#f92672>*</span>)(pPointCoordinates)),
        clientPointY(<span style=color:#f92672>*</span>(uint256_t<span style=color:#f92672>*</span>)(pPointCoordinates <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(uint256_t)));
    g1<span style=color:#f92672>::</span>affine_element clientPoint(clientPointX, clientPointY);
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>clientPoint.on_curve()) {
        errorStream <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Input point &#34;</span> <span style=color:#f92672>&lt;&lt;</span> clientPoint <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; is not on curve&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
        strcpy(pErrorMessage, errorStream.str().c_str());
        <span style=color:#66d9ef>return</span> false;
    }
    g1<span style=color:#f92672>::</span>affine_element sharedPoint <span style=color:#f92672>=</span> g1<span style=color:#f92672>::</span>affine_element(
        g1<span style=color:#f92672>::</span>element(clientPoint <span style=color:#f92672>*</span> fr(<span style=color:#ae81ff>2</span>)).mul_without_endomorphism(pServerState<span style=color:#f92672>-&gt;</span>privateKey <span style=color:#f92672>*</span> fr(<span style=color:#ae81ff>2</span>).invert()));
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>sharedPoint.on_curve()) {

        errorStream <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Shared point &#34;</span> <span style=color:#f92672>&lt;&lt;</span> sharedPoint <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; is not on curve&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
        strcpy(pErrorMessage, errorStream.str().c_str());

        <span style=color:#66d9ef>return</span> false;
    }
    uint256_t <span style=color:#a6e22e>sharedPointX</span>(sharedPoint.x), sharedPointY(sharedPoint.y);
    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>&gt;</span> hasherInput;
    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>&gt;</span> temp;
    <span style=color:#66d9ef>for</span> (size_t i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>sizeof</span>(uint256_t); i<span style=color:#f92672>++</span>) {
        hasherInput.push_back(((<span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span>)(<span style=color:#f92672>&amp;</span>sharedPointX.data[<span style=color:#ae81ff>0</span>]))[i]);
    }
    <span style=color:#66d9ef>for</span> (size_t i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>sizeof</span>(uint256_t); i<span style=color:#f92672>++</span>) {
        hasherInput.push_back(((<span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span>)(<span style=color:#f92672>&amp;</span>sharedPointY.data[<span style=color:#ae81ff>0</span>]))[i]);
    }
    temp.insert(temp.begin(), hasherInput.begin(), hasherInput.end());
    temp.push_back(<span style=color:#ae81ff>0</span>);
    <span style=color:#66d9ef>auto</span> encryptionKey <span style=color:#f92672>=</span> Sha256Hasher<span style=color:#f92672>::</span>hash(temp);
    temp.pop_back();
    temp.push_back(<span style=color:#ae81ff>1</span>);
    <span style=color:#66d9ef>auto</span> macKey <span style=color:#f92672>=</span> Sha256Hasher<span style=color:#f92672>::</span>hash(temp);

    memcpy(pServerState<span style=color:#f92672>-&gt;</span>sessionEncryptionKey, encryptionKey.data(), <span style=color:#ae81ff>32</span>);
    memcpy(pServerState<span style=color:#f92672>-&gt;</span>sessionMACKey, macKey.data(), <span style=color:#ae81ff>32</span>);
    <span style=color:#66d9ef>return</span> true;
}
</code></pre></div><p>If during ECDH key exchange the client&rsquo;s public point was not on the curve, the server responded with this information and ended the handshake. The weird thing was that the server also responded with shared point information, if the computed shared point was off the curve. This is a situation you should never run into, since you&rsquo;re getting an invalid point by scaling a valid one. However, as we covered earlier, the core bug resulted in erroneous field element squaring. This would make the point fall off the curve onto another one, which might not be as secure. To help solvers the original public point was actually doubled initially and then all operations were performed on the doubled point. This was done to stabilize the task, as I&rsquo;m not sure that a task with regular scalar multiplication would be solvable at all.</p>
<h3 id=finding-failure-inducing-points>Finding failure-inducing points<a hidden class=anchor aria-hidden=true href=#finding-failure-inducing-points>#</a></h3>
<p>The goal was to submit a valid point that would fall off the curve during the doubling operation. To understand how we could do that,let&rsquo;s look at how doubling of EC points is performed in barretenberg.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Fq</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Fr</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>void</span> element<span style=color:#f92672>&lt;</span>Fq, Fr, T<span style=color:#f92672>&gt;::</span>self_dbl() <span style=color:#66d9ef>noexcept</span>
{
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>constexpr</span> (Fq<span style=color:#f92672>::</span>modulus.data[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0x4000000000000000ULL</span>) {
        <span style=color:#66d9ef>if</span> (is_point_at_infinity()) {
            self_set_infinity();
            <span style=color:#66d9ef>return</span>;
        }
    } <span style=color:#66d9ef>else</span> {
        <span style=color:#66d9ef>if</span> (x.is_msb_set_word()) {
            self_set_infinity();
            <span style=color:#66d9ef>return</span>;
        }
    }

    <span style=color:#75715e>// T0 = x*x
</span><span style=color:#75715e></span>    Fq T0 <span style=color:#f92672>=</span> x.sqr();

    <span style=color:#75715e>// T1 = y*y
</span><span style=color:#75715e></span>    Fq T1 <span style=color:#f92672>=</span> y.sqr();

    <span style=color:#75715e>// T2 = T2*T1 = y*y*y*y
</span><span style=color:#75715e></span>    Fq T2 <span style=color:#f92672>=</span> T1.sqr();

    <span style=color:#75715e>// T1 = T1 + x = x + y*y
</span><span style=color:#75715e></span>    T1 <span style=color:#f92672>+=</span> x;

    <span style=color:#75715e>// T1 = T1 * T1
</span><span style=color:#75715e></span>    T1.self_sqr();

    <span style=color:#75715e>// T3 = T0 + T2 = xx + y*y*y*y
</span><span style=color:#75715e></span>    Fq T3 <span style=color:#f92672>=</span> T0 <span style=color:#f92672>+</span> T2;

    <span style=color:#75715e>// T1 = T1 - T3 = x*x + y*y*y*y + 2*x*x*y*y*y*y - x*x - y*y*y*y = 2*x*x*y*y*y*y = 2*S
</span><span style=color:#75715e></span>    T1 <span style=color:#f92672>-=</span> T3;

    <span style=color:#75715e>// T1 = 2T1 = 4*S
</span><span style=color:#75715e></span>    T1 <span style=color:#f92672>+=</span> T1;

    <span style=color:#75715e>// T3 = 3T0
</span><span style=color:#75715e></span>    T3 <span style=color:#f92672>=</span> T0 <span style=color:#f92672>+</span> T0;
    T3 <span style=color:#f92672>+=</span> T0;
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>constexpr</span> (T<span style=color:#f92672>::</span>has_a) {
        T3 <span style=color:#f92672>+=</span> (T<span style=color:#f92672>::</span>a <span style=color:#f92672>*</span> z.sqr().sqr());
    }

    <span style=color:#75715e>// z2 = 2*y*z
</span><span style=color:#75715e></span>    z <span style=color:#f92672>+=</span> z;
    z <span style=color:#f92672>*=</span> y;

    <span style=color:#75715e>// T0 = 2T1
</span><span style=color:#75715e></span>    T0 <span style=color:#f92672>=</span> T1 <span style=color:#f92672>+</span> T1;

    <span style=color:#75715e>// x2 = T3*T3
</span><span style=color:#75715e></span>    x <span style=color:#f92672>=</span> T3.sqr();

    <span style=color:#75715e>// x2 = x2 - 2T1
</span><span style=color:#75715e></span>    x <span style=color:#f92672>-=</span> T0;

    <span style=color:#75715e>// T2 = 8T2
</span><span style=color:#75715e></span>    T2 <span style=color:#f92672>+=</span> T2;
    T2 <span style=color:#f92672>+=</span> T2;
    T2 <span style=color:#f92672>+=</span> T2;

    <span style=color:#75715e>// y2 = T1 - x2
</span><span style=color:#75715e></span>    y <span style=color:#f92672>=</span> T1 <span style=color:#f92672>-</span> x;

    <span style=color:#75715e>// y2 = y2 * T3 - T2
</span><span style=color:#75715e></span>    y <span style=color:#f92672>*=</span> T3;
    y <span style=color:#f92672>-=</span> T2;
}
</code></pre></div><p>We see that doubling uses projective coordinates (instead of $(x,y)$ we have $(X,Y,Z)$). If you are unfamiliar with this form, it is used to speed up computation. Affine form $(x,y)$ depends on division during computation of $\lambda$ during addition and doubling operation. Division in finite fields is extremely computationally expensive, since you need to either exponentiate the value to the power of $p-2$ or use extended euclidean algorithm to find the inverse. Projective coordinate form deals with these pains by saving division for last. In projective form you have to perform expensive divison to convert back to affine form only after you&rsquo;ve computed the final point.</p>
<p>In the code we see several <em>sqr</em> and <em>self_sqr</em> calls that we are interested in here. For example, both $x$ and $y$ get squared, so why don&rsquo;t we simply place the bug-inducing value in $x$ or $y$ and try to compute a conforming point? There are 2 issues:</p>
<ol>
<li>Such a point might simply not exist. For example, if we set $x$ to a particular value, that doesn&rsquo;t automatically mean that the curve equation $y^2=x^3+b$ (the curve in barretenberg has $a=0$) will have roots (there is a 50% chance).</li>
<li>The initial check performed by the server ensures that $y^2=x^3+b$, so if we put the buggy value directly in $x$ or $y$ the first check will fail, so we need to be smarter.</li>
</ol>
<p>So we need to find other &ldquo;squares&rdquo;. Here they are:</p>
<ol>
<li>$3x^2$. We needed to check that $\frac{\mathit{buggy\_value}}{3}\ mod\ p$ is a quadratic residue, then compute two possible $x$ if it was and check if we could derive valid points from those.</li>
</ol>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>    <span style=color:#75715e>// T0 = x*x
</span><span style=color:#75715e></span>    Fq T0 <span style=color:#f92672>=</span> x.sqr();

    <span style=color:#75715e>// T3 = 3T0
</span><span style=color:#75715e></span>    T3 <span style=color:#f92672>=</span> T0 <span style=color:#f92672>+</span> T0;
    T3 <span style=color:#f92672>+=</span> T0;

    <span style=color:#75715e>// x2 = T3*T3
</span><span style=color:#75715e></span>    x <span style=color:#f92672>=</span> T3.sqr();
</code></pre></div><ol start=2>
<li>$y^2$. Here we needed to check that the buggy value is a quadratic residue and find solutions to equation $x^3+3-\mathit{buggy\_value}=0$</li>
</ol>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>    <span style=color:#75715e>// T1 = y*y
</span><span style=color:#75715e></span>    Fq T1 <span style=color:#f92672>=</span> y.sqr();

    <span style=color:#75715e>// T2 = T2*T1 = y*y*y*y
</span><span style=color:#75715e></span>    Fq T2 <span style=color:#f92672>=</span> T1.sqr();
</code></pre></div><ol start=3>
<li>$x+y^2$ We needed to find solutions to the equation $x^3+x+3-\mathit{buggy\_value}=0$. Then check that there are actually points on those $x$.</li>
</ol>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>    <span style=color:#75715e>// T0 = x*x
</span><span style=color:#75715e></span>    Fq T0 <span style=color:#f92672>=</span> x.sqr();

    <span style=color:#75715e>// T1 = y*y
</span><span style=color:#75715e></span>    Fq T1 <span style=color:#f92672>=</span> y.sqr();


    <span style=color:#75715e>// T1 = T1 + x = x + y*y
</span><span style=color:#75715e></span>    T1 <span style=color:#f92672>+=</span> x;

    <span style=color:#75715e>// T1 = T1 * T1
</span><span style=color:#75715e></span>    T1.self_sqr();
</code></pre></div><p>To simplify checks, I added a library function that just doubled the point using buggy code.</p>
<p>Barretenberg assumes that the point is on curve $y^2=x^3+b$, where $b$ is embedded in the point itself, so it takes no part in computation. Knowing $(x,y)$ it is easy to compute $b$ and then it&rsquo;s possible to compute the curve&rsquo;s order.</p>
<p>I factored all the orders and collected points with subgroups small enough to be useful. Once I had enough buggy points, I could send them to the server, get erroneous shared points and solve discrete logarithm in subgroups using pollard&rsquo;s rho algorithm. Using Chinese remainder theorem they could reconstruct the private key.</p>
<p>After reconstructing the private key contestants could simply assume the role of the server, replay the conversation with authentication and decrypt the password. Then all that was left is to submit it to the server.</p>
<h2 id=complete-solution>Complete Solution<a hidden class=anchor aria-hidden=true href=#complete-solution>#</a></h2>
<ol>
<li>Discover buggy flags in assembly, create a script to generate various inputs triggering those bugs and producing erroneous squared values</li>
<li>Convert those values back from Montgomery form.</li>
<li>Put them into the three equations and check if there are roots.</li>
<li>If there are roots, compute the points.</li>
<li>Check that the points actually trigger bugs and if they do, save them and resulting points on other curves.</li>
<li>Check curves' orders. Factor them and collect subgroups with solvable dlog.</li>
<li>Once there are enough subgroups so that the CRT of their orders is larger than the original scalar group order by a few factors, switch to interacting with the server.</li>
<li>Send buggy points to the server and receive shared points that should now be on other curves.</li>
<li>Solve appropriate subgroup dlogs.</li>
<li>Reconstuct server&rsquo;s private key</li>
<li>Replay the legitimate capture that is distributed with the task, assuming the role of the server and get the decrypted password.</li>
<li>Send it to the server and get the flag.</li>
</ol>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://cryptography.zone/tags/ctf/>CTF</a></li>
<li><a href=https://cryptography.zone/tags/cryptography/>Cryptography</a></li>
<li><a href=https://cryptography.zone/tags/bugs/>Bugs</a></li>
<li><a href=https://cryptography.zone/tags/asm/>ASM</a></li>
</ul>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share CTFZone 2022 Buggy ASM challenge writeup on twitter" href="https://twitter.com/intent/tweet/?text=CTFZone%202022%20Buggy%20ASM%20challenge%20writeup&url=https%3a%2f%2fcryptography.zone%2fposts%2fbuggy-asm%2f&hashtags=CTF%2cCryptography%2cBugs%2cASM"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share CTFZone 2022 Buggy ASM challenge writeup on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fcryptography.zone%2fposts%2fbuggy-asm%2f&title=CTFZone%202022%20Buggy%20ASM%20challenge%20writeup&summary=CTFZone%202022%20Buggy%20ASM%20challenge%20writeup&source=https%3a%2f%2fcryptography.zone%2fposts%2fbuggy-asm%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share CTFZone 2022 Buggy ASM challenge writeup on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcryptography.zone%2fposts%2fbuggy-asm%2f&title=CTFZone%202022%20Buggy%20ASM%20challenge%20writeup"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share CTFZone 2022 Buggy ASM challenge writeup on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcryptography.zone%2fposts%2fbuggy-asm%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share CTFZone 2022 Buggy ASM challenge writeup on whatsapp" href="https://api.whatsapp.com/send?text=CTFZone%202022%20Buggy%20ASM%20challenge%20writeup%20-%20https%3a%2f%2fcryptography.zone%2fposts%2fbuggy-asm%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share CTFZone 2022 Buggy ASM challenge writeup on telegram" href="https://telegram.me/share/url?text=CTFZone%202022%20Buggy%20ASM%20challenge%20writeup&url=https%3a%2f%2fcryptography.zone%2fposts%2fbuggy-asm%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://cryptography.zone/>Random thoughts about applied cryptography and fuzzing</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>